# 목표 자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기.

## JVM이란 무엇인가.
- java virtual machine (자바 가상 머신)
- .class 파일(바이트 코드)을 os가 이해할 수 있는 코드로 바꿔줌.
- 자바(jvm언어) 프로그램이 실행될 때, jvm이 os에게 메모리를 할당받음.
- 크게 클래스 로더, 메모리, 실행엔진으로 구성되어 있음.

### 클래스 로더
- .class 에서 바이트 코드를 읽고 메모리에 저장. 
- 런타임에 클래스 파일을 처음 참조할 때에, 로딩, 링크, 초기화 과정을 거친다.  

#### 로딩 
- 클래스 파일 로드
- 동적으로 클래스 정보가 필요할 때에, 클래스 파일을 로드.
- Bootstrap, Platform, Application 로더가 존재.
  - Application 로더가 클래스 정보를 로드하고, 자신이 로드할 수 없는 클래스는 Platform 로더에게 역할을 위임. 
  - Platform 로더가 클래스 정보를 로드하고, 자신이 로드할 수 없는 클래스는 Bootstrap 로더에게 역할을 위임.
  - Bootstrap 로더가 클래스 정보를 로드하고, 없으면 ClassNotFound Exception 을 발생시킴.

#### 링크
- 읽은 .class 의 바이트 코드 올바른 지 검증.
- static 변수를 메모리 할당.
- symbolic 메모리 주소를 Physical 메모리 주소 값으로 바꾸어준다. (-> 주소 바인딩)
  - Symbolic 메모리 주소 : 프로그래머가 사용하는 변수
    ```
    int a = 10; // a 가 symbolic memory 주소
    ```
  - Physical 메모리 주소 : 숫자로 이루어진 실제 메모리 주소 (e.g. 0x10000)
  - 즉, 변수를 실제 메모리 주소로 매핑.

#### 초기화
- static 변수에 값 초기화.
- static block 실행.

### 메모리
- 스택, 네이티브 메소드 스택, PC, 힙, 메소드 영역이 존재.

#### 스택
- 쓰레드마다 런타임 스택을 만듬.
- 그 스택에 메소드 호출될 때마다 스택 프레임이라는 블럭(저장 공간)을 쌓음.
- 스택 프레임 안에는 메소드 호출 시의 파라미터, 리턴값, 지역 변수, 기타 연산 값들을 저장.
- 메소드 수행이 끝나면 삭제.
- 프레임이 많이 쌓여서 쓰레드가 사용할 수 있는 스택의 사이즈를 넘기게 되면 StackOverFlowError 발생. 
- 스택의 사이즈를 확장하거나 새로운 쓰레드에 할당할 메모리가 없으면 OutOfMemoryError 발생.  

#### 네이티브 메소드 스택
- java의 기본 라이브러리는 c나 c++로 구현되어 있음.  
  - e.g. Thread.run()  
- 그 코드가 실행할 때, 네이티브 메소드 스택이 생김.
- jvm 스택과 마찬가지로, StackOverFlowError, OutOfMemoryError 발생할 수 있음.

#### PC register
- 쓰레드마다 PC (Program Counter) 레지스터를 만듬.
- 쓰레드 내에서 다음에 실행할 명령어의 위치를 저장하고 있음.
- PC register 정보를 가지고 프로그램 플로우 (loops, jump, exceptions ..)를 진행.

#### 힙
- 모든 쓰레드가 공유하는 메모리 자원.
- 
#### 메소드

### 실행 엔진